/* -*- coding: euc-jp; -*- */
/***en @page m17nDBFormat Data format of the m17n database

This section describes formats of these data supplied by the m17n
database.

<ul>
<li> @ref mdbGeneral "General" -- General Format
<li> @ref mdbCharsetList "CharsetList" -- List of character set definitions 
<li> @ref mdbCodingList "CodingList" -- List of coding system definitions
<li> @ref mdbDir "Dir" -- List of data in a database directory.
<li> @ref mdbFLT "FLT" -- Font Layout Table
<li> @ref mdbFontEncoding "FontEncoding" -- Font Encoding
<li> @ref mdbFontSize "FontSize" -- Font Size
<li> @ref mdbFontset "Fontset" -- Fontset
<li> @ref mdbIM "IM" -- Input Method
</ul>
*/
/***ja @page m17nDBFormat M17N データベースのデータ・フォーマット

ここでは、M17N データベースで提供される各データのフォーマットを解説す
る。

<ul>
<li> @ref mdbGeneral "General" -- 一般的なフォーマット
<li> @ref mdbCharsetList "CharsetList" -- 文字セット定義のリスト
<li> @ref mdbCodingList "CodingList" -- コード系定義のリスト
<li> @ref mdbDir "Dir" -- データベースディレクトリ中のデータのリスト
<li> @ref mdbFLT "FLT" -- フォントレイアウトテーブル
<li> @ref mdbFontEncoding "FontEncoding" -- フォントエンコーディング
<li> @ref mdbFontSize "FontSize" -- フォントサイズ
<li> @ref mdbFontset "Fontset" -- フォントセット
<li> @ref mdbIM "IM" -- インプットメソッド
</ul>
*/
/***ja

@section mdbGeneral 一般的なフォーマット

@subsection general-description 説明

関数 mdatabase_load () は、第一タグが @c Mchartable か @c Mcharset で
ない限り、タグで指定されたデータをプロパティリストの形で返す。返される
プロパティリストのキーは<tt>Minteger</tt>, <tt>Msymbol</tt>,
<tt>Mtext</tt>, <tt>Mplist</tt> に限る。値の型はキーによって曖昧性なく
決定される。キーが <tt>Minteger</tt> ならば値は整数値であり、キーが 
<tt>Msymbol</tt> なら値はシンボル、<tt>Mtext</tt> ならば M-text、
<tt>Mplist</tt> ならばプロパティリストである。

プロパティリストを示すためにはさまざまな表現形式が可能である。たとえば
<tt>(K1:V1, K2:V2, ..., Kn:Vn)</tt> という形で、最初のK1 と V1、二つ目
のキーと値がK2 と V2 といったプロパティリストを表現することもできる。
しかし、m17n データベースで用いられるプロパティリストのタイプはかなり
限定されているので、もっと単純な表現形式を用いることができる。

これ以降、プロパティリストの示すためには S 式に類似した表現を用いる。
(実際 m17n ライブラリのデフォルトのデータベースローダはこの表現で書か
れたデータファイルを読むように設計されている。)

この表現形式は 1 ないしそれ以上の <i>要素 (element)</i> からなる。個々
の要素はプロパティすなわちプロパティリストの一つの要素を表す。

要素間は 1 ないしそれ以上の <i> 空白 (whitespace)</i> すなわちスペース
(code 32)、タブ (code 9)、改行 (code 10) のいずれかで区切られる。セミ
コロン(<tt>;</tt>) で始まる行はコメントである。

各プロパティのキーと値は、要素のタイプに基づいて以下のように決定される。

<ul>

<li> 整数

正規表現<tt>-?[0-9]+</tt> または<tt>0[xX][0-9A-Fa-f]+</tt> に合致する
要素は、キーが<tt>Minteger</tt>であるプロパティを示す。最初の正規表現
と合致するものは 10 進の整数、後の正規表現と合致するものは 16 進の整数
と解釈し、その解釈の結果がプロパティの値である。

たとえば、要素 <tt>0xA0</tt> は10 進で 160 を値とするプロパティである。

<li> シンボル

正規表現<tt>[^-0-9(]([^\\()]|\\.)+</tt> に合致する要素は、キーが<tt>
Msymbol</tt>であるプロパティを示す。要素中の <tt>\\t</tt>,
<tt>\\n</tt>, <tt>\\r</tt>, <tt>\\e</tt> はそれぞれ、タブ (code 9)、改
行 (code 10)、復帰(code 13)、エスケープ (code 27) に置き換えられる。バッ
クスラッシュに続く他の文字はそれ自身と解釈される。プロパティの値は、結
果として得られる文字列を名前として持つシンボルである。

たとえば、要素 <tt>abc\ def</tt> は "abc def" を名前として持つシンボル
を値とするプロパティである。

<li> MTEXT

正規表現 <tt>"([^"]|\\")*"</tt> に合致する要素は、キー <tt>Mtext</tt> 
であるプロパティを示す。上記のバックスラッシュによるエスケープはここで
も有効である。さらに、要素中の正規表現
<tt>\\[xX][0-9A-Fa-f][0-9A-Fa-f]</tt> に合致する部分は、16進で解釈した
結果に置き換えられる。

バックスラッシュエスケープを処理した上で、ダブルクオートにはさまれたバ
イト列をUTF-8 列として解釈し、M-text にデコードする。この M-text がプ
ロパティの値である。

<li> PLIST

対応する括弧にはさまれた 0 個以上の要素は<tt>Mplist</tt> をキーとする
プロパティを示す。括弧の前後の空白は取り除かれる。プロパティの値は、プ
ロパティリストであり、その括弧内の各要素を再帰的に解釈した結果である。

</ul>

@subsection general-syntax 文法の表記

データのプロパティリストフォーマットの説明では、BNF風の記法が用いられ
る。この記法では、非終端は大文字（間に'-'が入ってもよい） で、終端は " 
で囲って表される。特別な非終端 INTEGER, SYMBOL,
MTEXT, PLIST はそれぞれ対応するプロパティを意味する。

@subsection general-example 例

次の単純な形式のプロパティリストに読み込まれる、データベースのデータの
一例を示す：

@verbatim
DATA-FORMAT ::=
    [ INTEGER | SYMBOL | MTEXT | FUNC ] *

FUNC ::=
    '(' FUNC-NAME FUNC-ARG * ')'

FUNC-NAME ::=
    SYMBOL

FUNC-ARG ::=
    INTEGER | SYMBOL | MTEXT | '(' FUNC-ARG ')'
@endverbatim

たとえば、次のテキストを含むデータファイルは上の文法に合致する：

@verbatim
abc 123 (pqr 0xff) "m\"text" (_\\_ ("string" xyz) -456)
@endverbatim

そして次のようなプロパティリストとして読み込まれる：

@verbatim
第１要素: キー: Msymbol,  値: abc
第２要素: キー: Minteger, 値: 123
第３要素: キー: Mplist,   値: 次の要素からなるプロパティリスト
    第１要素: キー Msymbol,  値: pgr
    第２要素: キー Minteger, 値: 255
第４要素: キー: Mtext,    値: m"text
第５要素: キー: Mplist,   値: 次の要素からなるプロパティリスト
    第１要素: キー: Msymbol, 値: _\_
    第２要素: キー: Mplist,  値: 次の要素からなるプロパティリスト
        第１要素: キー: Mtext,    値: string
	第２要素: キー: Msymbol,  値: xyz
	第３要素: キー: Minteger, 値: -456
@endverbatim
*/
/***en

@section mdbGeneral General Format

@subsection general-description DESCRIPTION

The mdatabase_load () function returns the data specified by tags in
the form of plist if the first tag is not @c Mchartable nor @c
Mcharset.  The keys of the returned plist are limited to
<tt>Minteger</tt>, <tt>Msymbol</tt>, <tt>Mtext</tt>, and
<tt>Mplist</tt>.  The type of the value is unambiguously determined by
the corresponding key.  If the key is <tt>Minteger</tt>, the value is
an integer.  If the key is <tt>Msymbol</tt>, the value is a symbol.
And so on.

A number of expressions are possible to represent a plist.  For
instance, we can use the form <tt>(K1:V1, K2:V2, ..., Kn:Vn)</tt> to
represent a plist whose first property key and value are K1 and V1,
second key and value are K2 and V2, and so on.  However, we can use a
simpler expression here because the types of plists used in the m17n
database are fairly restricted.

Hereafter, we use an expression, which is similar to S-expression, to
represent a plist.  (Actually, the default database loader of the m17n
library is designed to read data files written in this expression.)

The expression consists of one or more <i>elements</i>.  Each element
represents a property, i.e. a single element of a plist.

Elements are separated by one or more <i>whitespaces</i>, i.e. a space
(code 32), a tab (code 9), or a newline (code 10).  Comments begin
with a semicolon (<tt>;</tt>) and extend to the end of the line.

The key and the value of each property are determined based on the
type of the element as explained below.

<ul>

<li> INTEGER

An element that matches the regular expression <tt>-?[0-9]+</tt> or
<tt>0[xX][0-9A-Fa-f]+</tt> represents a property whose key is
<tt>Minteger</tt>.  An element matching the former expression is
interpreted as an integer in decimal notation, and one matching the
latter is interpreted as an integer in hexadecimal notation.  The
value of the property is the result of interpretation.

For instance, the element <tt>0xA0</tt> represents a property whose
value is 160 in decimal.

<li> SYMBOL

An element that matches the regular expression
<tt>[^-0-9(]([^\\()]|\\.)+</tt> represents a property whose key is
<tt> Msymbol</tt>.  In the element, <tt>\\t</tt>, <tt>\\n</tt>,
<tt>\\r</tt>, and <tt>\\e</tt> are replaced with tab (code 9), newline
(code 10), carriage return (code 13), and escape (code 27)
respectively.  Other characters following a backslash is interpreted
as it is.  The value of the property is the symbol having the
resulting string as its name.

For instance, the element <tt>abc\ def</tt> represents a property
whose value is the symbol having the name "abc def".

<li> MTEXT

An element that matches the regular expression <tt>"([^"]|\\")*"</tt>
represents a property whose key is <tt>Mtext</tt>.  The backslash
escape explained above also applies here.  Moreover, each part in the
element matching the regular expression <tt>
\\[xX][0-9A-Fa-f][0-9A-Fa-f]</tt> is replaced with its hexadecimal
interpretation.

After having resolved the backslash escapes, the byte sequence between
the double quotes is interpreted as a UTF-8 sequence and decoded into
an M-text.  This M-text is the value of the property.

<li> PLIST

Zero or more elements surrounded by a pair of parentheses represent a
property whose key is <tt>Mplist</tt>.  Whitespaces before and after a
parenthesis can be omitted.  The value of the property is a plist,
which is the result of recursive interpretation of the elements
between the parentheses.

</ul>

@subsection general-syntax SYNTAX NOTATION

In an explanation of a plist format of data, a BNF-like notation is
used.  In the notation, non-terminals are represented by a string of
uppercase letters (including '-' in the middle), terminals are
represented by a string surrounded by '"'.  Special non-terminals
INTEGER, SYMBOL, MTEXT and PLIST represents property integer, symbol,
M-text, or plist respectively.

@subsection general-example EXAMPLE

Here is an example of database data that is read into a plist of this
simple format:

@verbatim
DATA-FORMAT ::=
    [ INTEGER | SYMBOL | MTEXT | FUNC ] *

FUNC ::=
    '(' FUNC-NAME FUNC-ARG * ')'

FUNC-NAME ::=
    SYMBOL

FUNC-ARG ::=
    INTEGER | SYMBOL | MTEXT | '(' FUNC-ARG ')'
@endverbatim

For instance, a data file that contains this text matches the above
syntax:

@verbatim
abc 123 (pqr 0xff) "m\"text" (_\\_ ("string" xyz) -456)
@endverbatim

and is read into this plist:

@verbatim
1st element: key: Msymbol,  value: abc
2nd element: key: Minteger, value: 123
3rd element: key: Mplist,   value: a plist of these elements:
    1st element: key Msymbol,  value: pgr
    2nd element: key Minteger, value: 255
4th element: key: Mtext,    value: m"text
5th element: key: Mplist,   value: a plist of these elements:
    1st element: key: Msymbol, value: _\_
    2nd element: key: Mplist,  value: a plist of these elements:
        1st element: key: Mtext,    value: string
	2nd element: key: Msymbol,  value: xyz
	3rd element: key: Minteger, value: -456
@endverbatim
*/
/***ja

@section mdbCharsetList 文字セット定義のリスト

@subsection cslist-description 説明

m17n ライブラリは、タグ \<charset-list\> を持つデータから文字セット定義
のリストをロードする。データは以下のフォーマットのプロパティリストとし
てロードされる。

@verbatim
CHARSET-LIST ::= DEFINITION *

DEFINITION ::= '(' NAME ( KEY VALUE ) * ')'

NAME ::= SYMBOL

KEY ::= SYMBOL

VALUE ::= SYMBOL | INTEGER | MTEXT | PLIST
@endverbatim

@c NAME は定義する文字セットの名前である。

@c KEY と @c VALUE のペアは、関数 mchar_define_charset () に第２引数
$PLIST の要素として与えられるプロパティである。

@subsection cslist-seealso SEE ALSO

@ref mdbGeneral "mdbGeneral(5)", mchar_define_charset ()
*/
/***en

@section mdbCharsetList List of character set definitions 

@subsection cslist-description DESCRIPTION

The m17n library loads a list of charset definitions from the data of
tag \<charset-list\>.  The data is loaded as a plist of this format.

@verbatim
CHARSET-LIST ::= DEFINITION *

DEFINITION ::= '(' NAME ( KEY VALUE ) * ')'

NAME ::= SYMBOL

KEY ::= SYMBOL

VALUE ::= SYMBOL | INTEGER | MTEXT | PLIST
@endverbatim

@c NAME is a name of a charset to define.

@c KEY and @c VALUE pair is a property given to the function
mchar_define_charset () as an element of the second argument $PLIST.

@subsection cslist-seealso SEE ALSO

@ref mdbGeneral "mdbGeneral(5)", mchar_define_charset ()
*/
/***ja

@section mdbCodingList コード系定義のリスト

@subsection coding-list-description 説明

m17n ライブラリは、初期化の際 m17n データベースのタグ \<coding-list\> 
のついたデータからコード系定義のリストをロードする。このデータは以下の
フォーマットのプロパティリストとしてロードされる。

@verbatim
CODING-LIST ::= DEFINITION *

DEFINITION ::= '(' NAME ( KEY VALUE ) * ')'
NAME ::= SYMBOL

KEY ::= SYMBOL

VALUE ::= SYMBOL | INTEGER | MTEXT | PLIST
@endverbatim

@c NAME は定義するコード系の名前である。

@c KEY と @c VALUE のペアは、関数 mchar_define_coding () に２番目の引
数として与えられるプロパティである。

@subsection coding-list-seealso 参照

@ref mdbGeneral "mdbGeneral(5)", mconv_define_coding ()
*/
/***en

@section mdbCodingList List of coding system definitions

@subsection coding-list-description DESCRIPTION

The m17n library loads a list of coding system definitions from the
m17n database by the tags \<coding-list\> at initialization time.  The
data is loaded as a plist of this format.

@verbatim
CODING-LIST ::= DEFINITION *

DEFINITION ::= '(' NAME ( KEY VALUE ) * ')'
NAME ::= SYMBOL

KEY ::= SYMBOL

VALUE ::= SYMBOL | INTEGER | MTEXT | PLIST
@endverbatim

@c NAME is a name of a coding system to define.

@c KEY and @c VALUE pair is a property given to the function
mconv_define_coding () as the second argument.

@subsection coding-list-seealso SEE ALSO

@ref mdbGeneral "mdbGeneral(5)", mconv_define_coding ()
*/
/***ja

@section mdbDir データベースディレクトリ中のデータのリスト

@subsection dir-description 説明

m17n ライブラリは初期化の際、m17n データベース中のデータ定義のリストを
各データベースディレクトリ中の "mdb.dir" という名前を持つファイルからロー
ドする。このファイルにおけるプロパティリストのフォーマットは以下である。

@verbatim
MDB-DIR ::= DEFINITION *

DEFINITION ::= '(' TAG [ TAG [ TAG [ TAG ] ] ] FILE ')'

TAG ::= SYMBOL

FILE ::= MTEXT
@endverbatim
*/
/***en

@section mdbDir List of data in a database directory.

@subsection dir-description DESCRIPTION

The m17n library loads a list of definitions of data of the m17n
database from files of name "mdb.dir" in each database directory at
initialization time.  The plist format of this file is as follows:

@verbatim
MDB-DIR ::= DEFINITION *

DEFINITION ::= '(' TAG [ TAG [ TAG [ TAG ] ] ] FILE ')'

TAG ::= SYMBOL

FILE ::= MTEXT
@endverbatim
*/
/***ja

@section mdbFLT フォントレイアウトテーブル

@subsection flt-description 説明

単純なスクリプトの場合、表示エンジンは選択したフォントのエンコーディン
グに応じて文字コードをグリフコードに一文字ずつ変換する。しかし、複雑な
レイアウトを要求する文書、たとえばタイやインド系のスクリプトなどの場合、
１対１の変換では不十分である。複数の文字が一つのリガチャとして描かれたり、
２次元的にずらした位置に描かなくてはならないグリフがあったりする。

このような複雑なスクリプトを処理するため、m17n ライブラリはフォントレ
イアウトテーブル (短縮して FLT と呼ぶことにする) を用いる。FLT ドライ
バは FLT を解釈し、文字列を表示エンジンに渡すことのできるグリフ列に変
換する。

FLT は OpenType Layout Table に見られる情報 (CMAP, GSUB, and GPOS) に
加えて、文字列から書記素 (grapheme) クラスタを抽出したり、クラスタ内で
文字を並べ変えたりするための情報を持つことができる。

FLT は 1 つ以上の変換ステージが続いたものである。各ステージでコード列
は別のものに変換され、次のステージに読まれる。列の長さはステージ毎に異
なることがある。コード列の各要素は以下の整数値の属性を持つ。

<ul>
<li> コード

変換の最初のステージでは、元の文字列の文字コード。最後のステージでは、
表示エンジンに渡されるグリフコード。それ以外では中間的なグリフコード。

<li> カテゴリ

そのステージの @c CATEGORY-TABLE で定義されたカテゴリーコード。

<li> 結合規則

0 でなければ、この（中間）グリフを前のものとどう結合するかを指定する。

<li> 左パディングフラグ

0 でなければ、表示関数にこの（中間）グリフの前にスペースを挿入して、前
のグリフと重ならないようにするよう指示する。

<li> 右パディングフラグ

0 でなければ、表示関数にこの（中間）グリフの後にスペースを挿入して、後
のグリフと重ならないようにするよう指示する。

</ul>

レイアウトエンジンがテキストを描く際には、まずテキストの各文字に対して
それぞれフォントとFLT を決定する。同じフォントと FLT を用いる部分文字
列に関して、レイアウトエンジンは対応する中間的なグリフの列を生成する。
中間的なグリフコードの各要素は、コードの属性として対応する文字コード、
他の属性として 0 を持つ。この列はFLT の最初のステージで現行の @e ラン 
(部分列) として処理される。

各ステージは以下のように働く。

まずこのステージに @c CATEGORY-TABLE があれば、現行のランのすべてのグ
リフのカテゴリが更新される。カテゴリの無いグリフがあれば、ランはそのグ
リフの前で終る。

次にこのステージのコードオフセット、結合規則、左パディングフラグが 0 
に初期化される。

次いで、このステージの最初の変換規則が現行のランに適用される。

最後に現行のランは新しく作られた（中間）グリフ列に置き換えられる。

@subsection flt-syntax 文法と意味

m17n ライブラリ は m17n データベースからタグ \<font, layouter,
FLT-NAME\> を用いて FLT をロードする。FLT のデータのフォーマットは以下の通り：

@verbatim
FONT-LAYOUT-TABLE ::= STAGE0 STAGE *

STAGE0 ::= CATEGORY-TABLE GENERATOR

STAGE ::= CATEGORY-TABLE ? GENERATOR

CATEGORY-TABLE ::= '(' 'category' CATEGORY-SPEC + ')'

CATEGORY-SPEC ::= '(' CODE CATEGORY ')'
                  | '(' CODE CODE CATEGORY ')'

CODE ::= INTEGER

CATEGORY ::= INTEGER
@endverbatim

@c CATEGORY-SPEC の定義中で、 @c CODE はグリフコード @c CATEGORY は大
文字あるいは小文字の ASCII code、すなわち 'A', ... 'Z', 'a', .. 'z' の
いずれかである。

@c CATEGORY-SPEC の最初の形式は、@c CATEGORY をコード @c CODE を持つグ
リフに割り当て、二つ目の形式は @c CATEGORY を二つの @c CODE の間のコー
ドを持つグリフに割り当てる。

@verbatim
GENERATOR ::= '(' 'generator' RULE MACRO-DEF * ')'

RULE ::= REGEXP-BLOCK | MATCH-BLOCK | SUBST-BLOCK | COND-BLOCK
         | DIRECT-CODE | COMBINING-SPEC | OTF-SPEC
         | PREDEFINED-RULE | MACRO-NAME

MACOR-DEF ::= '(' MACRO-NAME RULE + ')'
@endverbatim

各 @c RULE は、消費するグリフと生成するグリフを指定する。「消費された」
グリフは現行のランから取り除かれる。ルールは状況によっては失敗する。明
示的に失敗と書かれている場合をのぞき、成功とみなす。

@verbatim
DIRECT-CODE ::= INTEGER
@endverbatim

このルールはグリフを消費せず、以下の属性を持つグリフを生成する。

<ul>
<li> コード : @c INTEGER ＋ デフォルトのコードオフセット
<li> 結合規則 : デフォルト値
<li> 左パデイングフラグ : デフォルト値
<li> 右パデイングフラグ : 0
</ul>

グリフ生成後、デフォルトのコードオフセット、結合規則, 左パディングフラ
グ はすべて 0 にリセットされる。

@verbatim
PREDEFINED-RULE ::= '=' | '*' | '<' | '>' | '|' | '[' | ']'
@endverbatim

これらは以下のように働く。

<ul>
<li> @c =

現行のランの最初のグリフを消費し、同じグリフを生成する。現行のランが空
ならば失敗する。

<li> @c *

前のルールを繰り返し実行する。前のルールが失敗すれば、何もせず失敗する。

<li> @c @<

書記素クラスタの始めを示す。

<li> @c @>

書記素クラスタの終りを示す。

<li> @c @[

この規則はデフォルトの左パディングフラグを 1 にする。グリフの消費や生
成はしない。

<li> @c @]

この規則は最近生成されたグリフの右パディングフラグを 1 にする。グリフ
の消費や生成はしない。

<li> @c |

グリフを消費せず、カテゴリが ' ' で他の属性が 0 である特別なグリフを生
成する。この規則だけがこの特別なグリフを生成する。

</ul>

@verbatim
REGEXP-BLOCK ::= '(' REGEXP RULE * ')'

REGEXP ::= MTEXT
@endverbatim

@c MTEXT は現行のランのカテゴリ列に合致すべき正規表現である。合致すれ
ば、この規則は一時的に現行のランを合致した部分だけに限定した上で、@c
RULE を実行する。合致した部分はこの規則によって消費される。

括弧のついた部分表現があれば、@c RULE の中に出現するかもしれない @c
MATCH-BLOCK によって使用するために記録される。

合致する部分が無ければ、この規則は失敗する。

@verbatim
MATCH-BLOCK ::= '(' MATCH-INDEX RULE * ')'

MATCH-INDEX ::= INTEGER
@endverbatim

@c MATCH-INDEX は直前の @c REGEXP-BLOCK によって記録された部分表現を指
定する整数である。このような部分表現があれば、この規則は一時的に現行の
ランを合致した部分表現だけに限定した上で、@c RULE を実行する。合致した
部分はこの規則によって消費される。

合致する部分が無ければ、この規則は失敗する。

この規則がステージの最初に規則であれば、@c MATCH-INDEX は 0 であり、現
行のラン全体に合致する。

@verbatim
SUBST-BLOCK ::= '(' SOURCE-PATTERN RULE * ')'

SOURCE-PATTERN ::= '(' CODE + ')'
                   | (' 'range' CODE CODE ')'
@endverbatim

現行のランのコード列が @c SOURCE-PATTERN と合致すれば、この規則は一時
的に現行のランを合致した部分だけに限定した上で、@c RULE を実行する。
合致した部分は消費される。

@c SOURCE-PATTERN の最初の形式は、合致するグリフコードの列を指定する。
この場合、この規則はデフォルトのコードオフセットを 0 にリセットする。

二つめの形式は、コード列の最初のグリフコードの範囲を指定する。この場合、
この規則はデフォルトのコードオフセットを最初のグリフコードから範囲を指
定する初めの @c CODE を引いたものに設定する。

合致する部分が無ければ、この規則は失敗する。

@verbatim
COND-BLOCK ::= '(' 'cond' RULE + ')'
@endverbatim

この規則は @c RULE を順に、どれかが成功するまで実行する。どのルールも
成功しなければ、この規則は失敗する。そうでなければ成功である。

@verbatim
OTF-SPEC ::= SYMBOL
@endverbatim

@c OTF-SPEC は、OTF ドライバへの指示を指定する名前を持つシンボルである。
名前は以下の文法に従う。

@verbatim
  OTF-SPEC-NAME ::= 'otf:' SCRIPT LANGSYS ? GSUB-FEATURES ? GPOS-FEATURES ?

  SCRIPT ::= SYMBOL

  LANGSYS ::= '/' SYMBOL

  GSUB-FEATURES ::= '=' FEATURE-LIST ?

  GPOS-FEATURES ::= '+' FEATURE-LIST ?

  FEATURE-LIST ::= ( SYMBOL ',' ) * [ SYMBOL | '*' ]

@endverbatim

各 @c SYMBOL は OpenType specification 中でのタグ名を指定する。

@c SCRIPT については、@c SYMBOL はスクリプトタグ名を表す。Devanagari 
は deva など。)

@c LANGSYS の場合は、@c SYMBOL は言語システムタグ名を指定する。@c
LANGSYS が省略されれば、デフォルトの言語システムテーブルが使用される。

@c GSUB-FEATURES では、 @c FEATURE LIST 中の各 @c SYMBOL は 適用する 
GSUB feature タグ名を指定する。'*' は残りすべての feature を指定するた
めに最後の要素として用いることができる。 @c SYMBOL の前に'~' がついて
おり、最後の要素が '*' ならば、@c SYMBOL は適用するfeature から除かれ
る。@c SYMBOL が指定されていなければ、GSUB feature は適用されない。@c
GSUB-FEATURES 自体が省略されればすべての GSUB feature が適用される。

@c GPOS-FEATURES の指定は @c GSUB-FEATURES の場合と同様である。

全てのタグ名は ASCII の４文字であること。

OpenType の指定方法については次のページを参照のこと。\n
    <http://www.microsoft.com/typography/otspec/default.htm>

@verbatim
COMBINING ::= SYMBOL
@endverbatim

@c COMBINING は、 次のグリフを前のものとどう結合するかの指示を名前とし
て持つシンボルである。このルールはデフォルトの結合規則をシンボル名固有
の整数コードにセットする。名前は以下の文法に従う。
following syntax.

@verbatim
  COMBINING-NAME ::= VPOS HPOS OFFSET VPOS HPOS

  VPOS ::= 't' | 'c' | 'b' | 'B'

  HPOS ::= 'l' | 'c' | 'r'

  OFFSET :: = '.' | XOFF | YOFF XOFF ?

  XOFF ::= ('<' | '>') INTEGER ?

  YOFF ::= ('+' | '-') INTEGER ?
@endverbatim

@c VPOS と @c HPOS は次のように垂直、水平位置を指定する。

@verbatim
                                POINT VPOS HPOS
                                ----- ---- ----
    0----1----2 <---- top       0     t    l
    |         |                 1     t    c
    |         |                 2     t    r
    |         |                 3     B    l
    9   10   11 <---- center    4     B    c
    |         |                 5     B    r
  --3----4----5-- <-- baseline  6     b    l
    |         |                 7     b    c
    6----7----8 <---- bottom    8     b    r
                                9     c    l
    |    |    |                10     c    c
  left center right            11     c    r
@endverbatim

左の図はあるグリフの 12 の参照点を 0 から 11 までの数字で示している。
四角形 0-6-8-2 はグリフの表示領域であり、位置3, 4, 5 はベースライン上
にある。 9 と 11 はそれぞれ線0-6 と 2-8 の中心である。1, 10, 4, 7 はそ
れぞれ線1-2, 3-5, 9-11, 6-8 の中心である。

右の表は、各参照点が@c VPOS と @c HPOS の組合せによってどのように指定
されるかを示している。

@c COMBINING-NAME の定義中の最初の @c VPOS と @c HPOS は、前のグリフの
参照点を、二つ目の @c VPOS と @c HPOS は次のグリフの参照点を指定する。
次のグリフはこの二個の参照点が重なるように描かれる。

@c OFFSET は重なりか他の詳細を指定する。'.' であれば、参照点二つは同じ
位置にある。

@c XOFF は、次のグリフの参照点の X 座標を、前の参照点からどれほど右 
('<') あるいは左 ('>') へずらすか指定する。

@c YOFF は、次のグリフの参照点の Y 座標を、前の参照点からどれほど上 
('+') あるいは下 ('-') へずらすか指定する。

どちらの場合にも、@c INTEGER はフォントサイズの何％ずらすかを示す値で
ある。すなわち、もし @c INTEGER が 10 ならばフォントサイズの10% (1/10) 
ずらすことになる。 @c INTEGER が省略された場合には、5 が指定されたもの
とする。

次のグリフが前のグリフに結合されると、それらは一つの結合グリフとして扱
われる。

@verbatim
MACRO-NAME ::= SYMBOL
@endverbatim

@c MACRO-NAME は @c MACRO-DEF のいずれかに現われるシンボルであり、対応
する@c RULE の列に展開される。

@subsection flt-context-dependent 文脈に依存する振舞

ここまでは、特定のフォントで描かれる各文字／グリフ列が文脈自由であるこ
と、すなわち前後のグリフに影響されないことを前提としてきた。これは、列 
S1 がフォントF1 によって描かれ、先行する列 S0 が常にフォント F0 を要求
する場合には正しい。

@verbatim
  列                            S0      S1
  現行のフォント                F0      F1
  利用可能なフォント            F0      F1
@endverbatim

しかし時には、列を明確に区切ることができない場合もある。先行する列 S0
が F0 だけでなく F1 でも描けるとしよう。

@verbatim
  列                            S0      S1
  現行のフォント                F0      F1
  利用可能なフォント            F0,F1   F1
@endverbatim

この場合、先行する S0 を描くために使われたグリフが S1 のグリフの生成に
影響を与えることもある。そこで S1 の処理の際にすでに処理の終った S0 に
関する情報にアクセスする必要がある。最初のステージ（このステージのみ）
の生成規則は、処理済みの部分へアクセスする特別な正規表現を許している。

@verbatim
  "RE0 RE1"
@endverbatim

@c RE0 と @c RE1 は先行の列 S0 と後続の列 S1 にそれぞれ対応する正規表
現である。

二つの正規表現の間のスペースに注意。これは特別なカテゴリ ' ' を示して
いる (上記参照) 。この正規表現はフォント F1 を使用するグリフ生成規則に
属しており、したがって RE1 だけでなくRE0 も F1 用のカテゴリを用いて表
現されなければならない。つまり、先行する列S0 が F1 用のカテゴリで表せ
ない場合には(上の最初の例のように) このパターンを持つ生成規則には合致
しない。

@subsection flt-seealso 参照

@ref mdbGeneral "mdbGeneral(5)", 
@ref flt-list "FLTs provided by the m17n database"
*/
/***en

@section mdbFLT Font Layout Table

@subsection flt-description DESCRIPTION

For simple scripts, the rendering engine converts character codes into glyph
codes one by one by consulting the encoding of each selected font.
But, to render text that requires complicated layout (e.g. Thai and
Indic scripts), one to one conversion is not sufficient.  A sequence
of characters may have to be drawn as a single ligature.  Some
glyphs may have to be drawn at 2-dimensionally shifted positions.

To handle those complicated scripts, the m17n library uses Font Layout
Tables (FLTs for short).  The FLT driver interprets an FLT and
converts a character sequence into a glyph sequence that is ready to
be passed to the rendering engine.

An FLT can contain information to extract a grapheme cluster from a
character sequence and to reorder the characters in the cluster, in
addition to information found in OpenType Layout Tables (CMAP, GSUB,
and GPOS).

An FLT is a cascade of one or more conversion stages.  In each stage, a
sequence is converted into another sequence to be read in the
next stage.  The length of sequences may differ from stage to
stage.  Each element in a sequence has the following integer attributes.

<ul>
<li> code

In the first conversion stage, this is the character code in the
original character sequence.  In the last stage, it is the glyph code
passed to the rendering engine.  In other cases, it is an intermediate
glyph code.

<li> category

This is the category code defined in the @c CATEGORY-TABLE
of the current stage.

<li> combining-spec

If nonzero, it specifies how to combine this (intermediate) glyph
with the previous one.

<li> left-padding-flag

If nonzero, it instructs the rendering function to insert a padding
space before this (intermediate) glyph so that the glyph does not
overlap with the previous one.

<li> right-padding-flag

If nonzero, it instructs the rendering function to insert a padding
space after this (intermediate) glyph so that the glyph does not
overlap with the next one.

</ul>

When the layout engine draws text, it at first determines a font and
an FLT for each character in the text.  For each subsequence of
characters that use use the same font and FLT, the layout engine
generates an intermediate glyph sequence from the character
subsequence.  Each element in the intermediate glyph sequence
has the corresponding character code as the code attribute and zeroes
for other attributes.  This sequence is processed in the
first stage of FLT as the current @e run (substring).

Each stage works as follows.

At first, if the stage has a @c CATEGORY-TABLE, the category of each glyph
in the current run is updated.  If there is a glyph that has no category,
the current run ends before that glyph.

Then, the default values of code-offset, combining-spec, and left-padding-flag
of this stage are initialized to zero.

Next, the initial conversion rule of the stage is applied to the
current run.

Lastly, the current run is replaced with the newly produced
(intermediate) glyph sequence.

@subsection flt-syntax SYNTAX and SEMANTICS

The m17n library loads an FLT from the m17n database using the tag
\<font, layouter, FLT-NAME\>.  The date format of an FLT is as follows:

@verbatim
FONT-LAYOUT-TABLE ::= STAGE0 STAGE *

STAGE0 ::= CATEGORY-TABLE GENERATOR

STAGE ::= CATEGORY-TABLE ? GENERATOR

CATEGORY-TABLE ::= '(' 'category' CATEGORY-SPEC + ')'

CATEGORY-SPEC ::= '(' CODE CATEGORY ')'
                  | '(' CODE CODE CATEGORY ')'

CODE ::= INTEGER

CATEGORY ::= INTEGER
@endverbatim

In the definition of @c CATEGORY-SPEC, @c CODE is a glyph code, and @c
CATEGORY is ASCII code of an upper or lower letter, i.e. one of 'A',
... 'Z', 'a', .. 'z'.

The first form of @c CATEGORY-SPEC assigns @c CATEGORY to a glyph
whose code @c CODE.  The second form assigns @c CATEGORY to glyphs
whose code falls between the two @c CODEs.

@verbatim
GENERATOR ::= '(' 'generator' RULE MACRO-DEF * ')'

RULE ::= REGEXP-BLOCK | MATCH-BLOCK | SUBST-BLOCK | COND-BLOCK
         | DIRECT-CODE | COMBINING-SPEC | OTF-SPEC
         | PREDEFINED-RULE | MACRO-NAME

MACOR-DEF ::= '(' MACRO-NAME RULE + ')'
@endverbatim

Each @c RULE specifies glyphs to be consumed and glyphs to be produced.  When
some glyphs are consumed, they are taken away from the current run.  A
rule may fail in some condition.  If not described explicitly to
fail, it should be regarded that the rule succeeds.

@verbatim
DIRECT-CODE ::= INTEGER
@endverbatim

This rule consumes no glyph and produces a glyph which has the
following attributes:

<ul>
<li> code : @c INTEGER plus the default code-offset
<li> combining-spec : default value
<li> left-padding-flag : default value
<li> right-padding-flag : zero
</ul>

After having produced the glyph, the default code-offset,
combining-spec, and left-padding-flag are all reset to zero.

@verbatim
PREDEFINED-RULE ::= '=' | '*' | '<' | '>' | '|' | '[' | ']'
@endverbatim

They perform actions as follows.

<ul>
<li> @c =

This rule consumes the first glyph in the current run and produces the
same glyph.  It fails if the current run is empty.

<li> @c *

This rule repeatedly executes the previous rule.
If the previous rule fails, this rule does nothing and fails.

<li> @c @<

This rule specifies the start of a grapheme cluster.

<li> @c @>

This rule specifies the end of a grapheme cluster.

<li> @c @[

This rule sets the default left-padding-flag to 1.
No glyph is consumed.  No glyph is produced.

<li> @c @]

This rule changes the right-padding-flag of the lastly generated
glyph to 1.
No glyph is consumed.  No glyph is produced.

<li> @c |

This rule consumes no glyph and produces a special glyph whose
category is ' ' and other attributes are zero.  
This is the only rule that produces that special glyph.

</ul>

@verbatim
REGEXP-BLOCK ::= '(' REGEXP RULE * ')'

REGEXP ::= MTEXT
@endverbatim

@c MTEXT is a regular expression that should match the sequence of
categories of the current run.  If a match is found, this rule
executes @c RULEs temporarily limiting the current run to the matched
part.  The matched part is consumed by this rule.

Parenthesized subexpressions, if any, are recorded to be used in @c
MATCH-BLOCK that may appear in one of @c RULEs.

If no match is found, this rule fails.

@verbatim
MATCH-BLOCK ::= '(' MATCH-INDEX RULE * ')'

MATCH-INDEX ::= INTEGER
@endverbatim

@c MATCH-INDEX is an integer specifying a parenthesized subexpression
recorded by the previous @c REGEXP-BLOCK.  If such a subexpression was
found by the previous regular expression matching, this rule executes @c
RULEs temporarily limiting the current run to the matched part
of the subexpression.  The matched part is consumed by this rule.

If no match was found, this rule fails.

If this is the first rule of the stage, @c MATCH-INDEX must be 0, and
it matches the whole current run.

@verbatim
SUBST-BLOCK ::= '(' SOURCE-PATTERN RULE * ')'

SOURCE-PATTERN ::= '(' CODE + ')'
                   | (' 'range' CODE CODE ')'
@endverbatim

If the sequence of codes of the current run matches @c SOURCE-PATTERN,
this rule executes @c RULEs temporarily limiting the current run to
the matched part.  The matched part is consumed.

The first form of @c SOURCE-PATTERN specifies a sequence of glyph codes to be
matched.  In this case, this rule resets the default code-offset to
zero.

The second form specifies a range of codes that should match the first
glyph code of the code sequence.  In this case, this rule sets the
default code-offset to the first glyph code minus the first @c CODE
specifying the range.


If no match is found, this rule fails.

@verbatim
COND-BLOCK ::= '(' 'cond' RULE + ')'
@endverbatim

This rule sequentially executes @c RULEs until one succeeds.  If no
rule succeeds, this rule fails.  Otherwise, it succeeds.

@verbatim
OTF-SPEC ::= SYMBOL
@endverbatim

@c OTF-SPEC is a symbol whose name specifies an instruction to the OTF
driver.  The name has the following syntax.

@verbatim
  OTF-SPEC-NAME ::= 'otf:' SCRIPT LANGSYS ? GSUB-FEATURES ? GPOS-FEATURES ?

  SCRIPT ::= SYMBOL

  LANGSYS ::= '/' SYMBOL

  GSUB-FEATURES ::= '=' FEATURE-LIST ?

  GPOS-FEATURES ::= '+' FEATURE-LIST ?

  FEATURE-LIST ::= ( SYMBOL ',' ) * [ SYMBOL | '*' ]

@endverbatim

Each @c SYMBOL specifies a tag name defined in the OpenType
specification.

For @c SCRIPT, @c SYMBOL specifies a Script tag name (e.g. deva for
Devanagari).

For @c LANGSYS, @c SYMBOL specifies a Language System tag name.  If @c
LANGSYS is omitted, the Default Language System
table is used.

For @c GSUB-FEATURES, each @c SYMBOL in @c FEATURE LIST specifies a GSUB Feature tag name
to apply.  '*' is allowed as the last item to specify all remaining
features.  If @c SYMBOL is preceded by '~' and the last item is '*',
@c SYMBOL is excluded from the features to apply.  If no @c SYMBOL is
specified, no GSUB feature is applied.  If @c GSUB-FEATURES itself is
omitted, all GSUB features are applied.

The specification of @c GPOS-FEATURES is analogous to that of @c
GSUB-FEATURES.

Please note that all the tags above must be 4 ASCII printable characters.

See the following page for the OpenType specification.\n
    <http://www.microsoft.com/typography/otspec/default.htm>

@verbatim
COMBINING ::= SYMBOL
@endverbatim

@c COMBINING is a symbol whose name specifies how
to combine the next glyph with the previous one.  This rule sets the
default combining-spec to an integer code that is unique to the symbol
name.  The name has the following syntax.

@verbatim
  COMBINING-NAME ::= VPOS HPOS OFFSET VPOS HPOS

  VPOS ::= 't' | 'c' | 'b' | 'B'

  HPOS ::= 'l' | 'c' | 'r'

  OFFSET :: = '.' | XOFF | YOFF XOFF ?

  XOFF ::= ('<' | '>') INTEGER ?

  YOFF ::= ('+' | '-') INTEGER ?
@endverbatim

@c VPOS and @c HPOS specify the vertical and horizontal positions
as described below.

@verbatim
                                POINT VPOS HPOS
                                ----- ---- ----
    0----1----2 <---- top       0     t    l
    |         |                 1     t    c
    |         |                 2     t    r
    |         |                 3     B    l
    9   10   11 <---- center    4     B    c
    |         |                 5     B    r
  --3----4----5-- <-- baseline  6     b    l
    |         |                 7     b    c
    6----7----8 <---- bottom    8     b    r
                                9     c    l
    |    |    |                10     c    c
  left center right            11     c    r
@endverbatim

The left figure shows 12 reference points of a glyph by numbers 0 to
11.  The rectangle 0-6-8-2 is the bounding box of the glyph, the
positions 3, 4, and 5 are on the baseline, 9 and 11 are on the center
of the lines 0-6 and 2-8 respectively, 1, 10, 4, and 7 are on the
center of the lines 1-2, 3-5, 9-11, and 6-8 respectively.

The right table shows how those reference points are specified by a
pair of @c VPOS and @c HPOS.

The first @c VPOS and @c HPOS in the definition of @c COMBINING-NAME
specify the
reference point of the previous glyph, and the second @c VPOS and @c
HPOS specify that of the next glyph.
The next glyph is drawn so that these two reference points align.

@c OFFSET specifies the way of alignment in detail.  If it is '.', the
reference points are on the same position.

@c XOFF specifies how much the X position of the reference point of
the next glyph should be shifted to the right ('<') or left ('>') from
the previous reference point.

@c YOFF specifies how much the Y position of the reference point the
next glyphshould be shifted upward ('+') or downward ('-') from the
previous reference point.

In both cases, @c INTEGER is the amount of shift expressed as a
percentage of the font size, i.e., if @c INTEGER is 10, it means
10% (1/10) of the font size.  If @c INTEGER is omitted, it is assumed that
5 is specified.

Once the next glyph is combined with the previous one, they
are treated as a single combined glyph.

@verbatim
MACRO-NAME ::= SYMBOL
@endverbatim

@c MACRO-NAME is a symbol that appears in one of @c MACRO-DEF.  It is
exapanded to the sequence of the correponding @c RULEs.

@subsection flt-context-dependent CONTEXT DEPENDENT BEHAVIOR

So far, it has been assumed that each sequence, which is drawn with a
specific font, is context free, i.e. not affected by the glyphs
preceding or following that sequence.  This is true when sequence S1
is drawn with font F1 while the preceding sequence S0 unconditionally
requires font F0.

@verbatim
  sequence                              S0      S1
  currently used font                   F0      F1
  usable font(s)                        F0      F1
@endverbatim

Sometimes, however, a clear separation of sequences is not possible.
Suppose that the preceding sequence S0 can be drawn not only with F0
but also with F1.

@verbatim
  sequence                              S0      S1
  currently used font                   F0      F1
  usable font(s)                        F0,F1   F1
@endverbatim

In this case, glyphs used to draw the preceding S0 may affect glyph
generation of S1.  Therefore it is necessary to access information
about S0, which has already been processed, when processing S1.
Generation rules in the first stage (only in the first stage) accept a
special regular expression to access already processed parts.

@verbatim
  "RE0 RE1"
@endverbatim

@c RE0 and @c RE1 are regular expressions that match the preceding
sequence S0 and the following sequence S1, respectively.

Pay attention to the space between the two regular expressions.  It
represents the special category ' ' (see above).  Note that the
regular expression above belongs to glyph generation rules using font
F1, therefore not only RE1 but also RE0 must be expressed with the
categories for F1.  This means when the preceding sequence S0 cannot
be expressed with the categories for F1 (as in the first example
above) generation rules having these patterns never match.

@subsection flt-seealso SEE ALSO

@ref mdbGeneral "mdbGeneral(5)", 
@ref flt-list "FLTs provided by the m17n database"
*/
/***ja

@section mdbFontEncoding フォントエンコーディング

@subsection font-encoding-description 説明

m17n ライブラリは、m17n データベースから \<font, encoding\> タグによっ
て個々のフォントのエンコーディングに関する情報をロードする。このデータ
は以下のフォーマットのプロパティリストとしてロードされる。

@verbatim
FONT-ENCODING ::= PER-FONT *

PER-FONT ::= '(' FONT-SPEC ENCODING [ REPERTORY ] ')'

FONT-SPEC ::=
    '(' [ FOUNDRY FAMILY
    	  [ WEIGHT [ STYLE [ STRETCH [ ADSTYLE ]]]]]
	REGISTRY ')'

ENCODING ::= SYMBOL
@endverbatim

@c FONT-SPEC はフォントのプロパティを指定する。@c FOUNDRY から @c
REGISTRY はフォントの #Mfoundry から #Mregistry プロパティに対応するシ
ンボルである。各プロパティの意味については @ref m17nFont 参照。

たとえばこの @c FONT-SPEC:

@verbatim
    (nil alice0\ lao iso8859-1)
@endverbatim

はフォントのファミリ名が "alice0 lao" でレジストリが "iso8859-1" であ
るすべてのフォントに適用できる。

@c ENCODING は文字セットを示すシンボルである。@c FONT-SPEC に合致する
フォントは、その文字セットの全文字をサポートし、その文字セットによって
文字コードはそのフォントの対応するグリフコードにマップされる。

@c REPERTORY は文字セットを示すシンボルか "nil" である。省略した場合は、
@c ENCODING を @c REPERTORY に指定したのと同じ意味になる。"nil" でなけ
れば、文字セットはフォントのレパートリ、すなわちサポートする文字を示す。
そうでなければ、特定の文字がそのフォントでサポートされているかどうかは
個々のフォントドライバに問い合わせる。

いわゆるユニコードフォント (レジストリは "iso10646-1") については、普
通ユニコード文字の一部しかサポートしていないため、@c REPERTORY を 
"nil" にすることが望ましい。     */
/***en

@section mdbFontEncoding Font Encoding

@subsection font-encoding-description DESCRIPTION

The m17n library loads information about the encoding of each font
form the m17n database by the tags \<font, encoding\>.  The data is
loaded as a plist of this format.

@verbatim
FONT-ENCODING ::= PER-FONT *

PER-FONT ::= '(' FONT-SPEC ENCODING [ REPERTORY ] ')'

FONT-SPEC ::=
    '(' [ FOUNDRY FAMILY
    	  [ WEIGHT [ STYLE [ STRETCH [ ADSTYLE ]]]]]
	REGISTRY ')'

ENCODING ::= SYMBOL
@endverbatim

@c FONT-SPEC is to specify properties of a font.  @c FOUNDRY to @c
REGISTRY are symbols corresponding to #Mfoundry to #Mregistry property
of a font.  See @ref m17nFont for the meaning of each property.

For instance, this @c FONT-SPEC:

@verbatim
    (nil alice0\ lao iso8859-1)
@endverbatim

should be applied to all fonts whose family name is "alice0 lao", and
registry is "iso8859-1".

@c ENCODING is a symbol representing a charset.  A font matching @c
FONT-SPEC supports all characters of the charset, and a character code
is mapped to the corresponding glyph code of the font by this charset.

@c REPERTORY is a symbol representing a charset or "nil".  Omitting it
is the same as specifying @c ENCODING as @c REPERTORY.  If it is not
"nil", the charset specifies the repertory of the font, i.e, which
character it supports.  Otherwise, whether a specific character is
supported by the font or not is asked to each font driver.

For so called Unicode fonts (registry is "iso10646-1"), it is
recommended to specify "nil" as @c REPERTORY because such fonts
usually supports only a subset of Unicode characters.  */
/***ja

@section mdbFontSize フォントサイズ

@subsection font-size-description 説明

時にフォントはそのサイズについて誤った情報を含んでいることがある (典型
的な例としては hack された TrueType フォントなど) 。このようなフォント
が他のフォントと一緒に使われると、レイアウトがおかしくなる。この問題を
解決するため、m17n ライブラリはm17n データベースからタグ \<font,
resize\> を持つデータをロードし、フォントサイズを調整するための情報とし
て用いる。このデータは以下のフォーマットを持つプロパティリストとしてロー
ドされる。

@verbatim
FONT-SIZE-ADJUSTMENT ::= PER-FONT *

PER-FONT ::= '(' FONT-SPEC ADJUST-RATIO ')'

FONT-SPEC ::=
    '(' [ FOUNDRY FAMILY
    	  [ WEIGHT [ STYLE [ STRETCH [ ADSTYLE ]]]]]
	REGISTRY ')'

ADJUST-RATIO ::= INTEGER
@endverbatim

@c FONT-SPEC はフォントのプロパティを指定する。@c FOUNDRY から @c
REGISTRY までは、それぞれフォントの #Mfoundry から #Mregistry プロパティ
までに対応している。各プロパティの意味については @ref m17nFont 参照のこと。

@c ADJUST-RATIO は、整数値であり、フォントサイズをどのように調整すれば
よいかをパーセントであらわす。たとえば以下の @c PER-FONT:

@verbatim
    ((devanagari-cdac) 150)
@endverbatim

は、m17n ライブラリのフォントハンドラに、"devanagari-cdac" というレジス
トリを持つフォントについては、要求された大きさの 1.5 倍のサイズのフォン
トを開くように指示するものである。

*/
/***en

@section mdbFontSize Font Size

@subsection font-size-description DESCRIPTION

In some case, a font contains incorrect information about its size
(typically in the case of a hacked TrueType font), which results in a
bad text layout when such a font is used in combination with the other
fonts.  To overcome this problem, the m17n library loads information
about font-size adjustment from the m17n database by the tags \<font,
resize\>.  The data is loaded as a plist of this format.

@verbatim
FONT-SIZE-ADJUSTMENT ::= PER-FONT *

PER-FONT ::= '(' FONT-SPEC ADJUST-RATIO ')'

FONT-SPEC ::=
    '(' [ FOUNDRY FAMILY
    	  [ WEIGHT [ STYLE [ STRETCH [ ADSTYLE ]]]]]
	REGISTRY ')'

ADJUST-RATIO ::= INTEGER
@endverbatim

@c FONT-SPEC is to specify properties of a font.  @c FOUNDRY to @c
REGISTRY are symbols corresponding to #Mfoundry to #Mregistry property
of a font.  See @ref m17nFont for the meaning of each property.

@c ADJUST-RATIO is an integer number specifying by percentage how much
the font-size must be adjusted.  For instance, this @c PER-FONT:

@verbatim
    ((devanagari-cdac) 150)
@endverbatim

instructs the font handler of the m17n library to open a font of 1.5
times bigger than a requested size on opening a font whose registry
is "devanagari-cdac".
*/
/***ja

@section mdbFontset フォントセット

@subsection fontset-description 説明

m17n ライブラリは、m17n データベースから \<fontset, FONTSET-NAME\> タ
グによってフォントセットの定義をロードする。このデータは以下のフォーマッ
トのプロパティリストとしてロードされる。

@verbatim
FONTSET ::= PER-SCRIPT * PER-CHARSET * FALLBACK *

PER-SCRIPT ::= '(' SCRIPT PER-LANGUAGE + ')'

PER-LANGUAGE ::= '(' LANGUAGE FONT-SPEC-ELEMENT + ')'

PER-CHARSET ::= '(' CHARSET FONT-SPEC-ELEMENT + ')'

FALLBACK ::= FONT-SPEC-ELEMENT

FONT-SPEC-ELEMENT ::= '(' FONT-SPEC [ FLT-NAME ] ')'

FONT-SPEC ::=
     '(' [ FOUNDRY FAMILY
           [ WEIGHT [ STYLE [ STRETCH [ ADSTYLE ]]]]]
         REGISTRY ')'
@endverbatim    

@c SCRIPT はスクリプト名 (e.g. latin, han) を示すシンボルか @c nilであ
る。@c LANGUAGE はISO 639 に定義された言語名コード (e.g. ja, zh) であ
る２文字のシンボルか @c nil である。

@c FONT-SPEC はフォントのプロパティを指定する。@c FOUNDRY から @c
REGISTRY はフォントの #Mfoundry から #Mregistry プロパティに対応するシ
ンボルである。各プロパティの意味については @ref m17nFont 参照。

@c FLT-NAME はフォントレイアウトテーブルの名前である。(@ref mdbFLT).

@subsection fontset-example 例

これは @c PER_SCRIPT の例である。

@verbatim
(han
  (ja
    ((jisx0208.1983-0)))
  (zh
    ((gb2312.1980-0)))
  (nil
    ((big5-0))))
@endverbatim

これによってフォントセレクタは、"han" 文字 (つまり#Mscript プロパティ
が 'han' である文字)のうち、文字の M-text 中での #Mlanguage テキストプ
ロパティが "ja" でありその文字がフォントのレパートリーに含まれていれも
のについては、レジストリが"jisx0208.1983-0" であるフォントを使うことを
指示される。そうでなければ、レジストリが "gb2312.1980-0" や"big5-0" で
あるものが試される。"han" 文字に #Mlanguage テキストプロパティが無けれ
ば、３つとも試される。

フォント選択の詳細については関数 mdraw_text () 参照。
*/
/***en

@section mdbFontset Fontset

@subsection fontset-description DESCRIPTION

The m17n library loads a fontset definition from the m17n database by
the tags \<fontset, FONTSET-NAME\>.  The plist format of the data is
as follows:

@verbatim
FONTSET ::= PER-SCRIPT * PER-CHARSET * FALLBACK *

PER-SCRIPT ::= '(' SCRIPT PER-LANGUAGE + ')'

PER-LANGUAGE ::= '(' LANGUAGE FONT-SPEC-ELEMENT + ')'

PER-CHARSET ::= '(' CHARSET FONT-SPEC-ELEMENT + ')'

FALLBACK ::= FONT-SPEC-ELEMENT

FONT-SPEC-ELEMENT ::= '(' FONT-SPEC [ FLT-NAME ] ')'

FONT-SPEC ::=
     '(' [ FOUNDRY FAMILY
           [ WEIGHT [ STYLE [ STRETCH [ ADSTYLE ]]]]]
         REGISTRY ')'
@endverbatim    

@c SCRIPT is a symbol of script name (e.g. latin, han) or @c nil.  @c
LANGUAGE is a two-letter symbol of language name code defined by ISO
639 (e.g. ja, zh) or @c nil.

@c FONT-SPEC is to specify properties of a font.  @c FOUNDRY to @c
REGISTRY are symbols corresponding to #Mfoundry to #Mregistry property
of a font.  See @ref m17nFont for the meaning of each property.

@c FLT-NAME is a name of Font Layout Table (@ref mdbFLT).

@subsection fontset-example EXAMPLE

This is an example of @c PER_SCRIPT.

@verbatim
(han
  (ja
    ((jisx0208.1983-0)))
  (zh
    ((gb2312.1980-0)))
  (nil
    ((big5-0))))
@endverbatim

It instructs the font selector to use a font of registry
"jisx0208.1983-0" for a "han" character (i.e. a character whose
#Mscript property is 'han') if the character has #Mlanguage text
property "ja" in an M-text and the character is in the repertories of
such fonts.  Otherwise, try a font of registry "gb2312.1980-0" or
"big5-0".  If that "han" character does not have #Mlanguage text
property, try all three fonts.

See the function mdraw_text () for the detail of how a font is
selected.
*/
/***ja

@section mdbIM インプットメソッド

@subsection im-description 説明

m17n ライブラリは、m17n データベースから動的にロードできる入力メソッド
ドライバを提供している。(@ref m17nInputMethod 参照。 @latexonly
(P.\pageref{group__m17nInputMethod}) @endlatexonly).

ここでは入力メソッド定義のデータフォーマットを説明する。

@subsection im-format 文法と意味

以下のデータフォーマットによって入力メソッドが定義される。ドライバはファ
イルやストリームから定義をロードし、プロパティリストの形式に変換する。

@verbatim
INPUT-METHOD ::= TITLE MAP-LIST MACRO-LIST ? MODULE-LIST ? STATE-LIST

TITLE ::= '(' 'title' MTEXT ')'
@endverbatim

@c MTEXT はこの入力メソッドが有効な際スクリーン上に表示されるテキストである 。

@verbatim 
MAP-LIST ::= '(' 'map' MAP * ')'

MAP ::= '(' MAP-NAME RULE * ')'

MAP-NAME ::= SYMBOL

RULE ::= '(' KEYSEQ MAP-ACTION * ')'

KEYSEQ ::= MTEXT | '(' [ SYMBOL | INTEGER ] * ')'
@endverbatim

@c MAP-NAME 定義中の @c SYMBOL は、 @c t あるいは @c nil であってはな
らない。

@c KEYSEQ 定義中の @c MTEXT は、キーボードから生成できる文字で構成され
る。すなわち @c MTEXT は通常ASCII 文字のみを含む。しかし、入力メソッド
がたとえば西ヨーロッパ用キーボードを使うことを想定したものであれば、@c
MTEXT は Latin-1 文字を含んでもよい。

@c KEYSEQ 定義中の @c SYMBOL は、関数 minput_event_to_key () の戻り値
でなくてはならない。

@c KEYSEQ 定義中の @c INTEGER は、有効な文字コードでなくてはならない。

@verbatim
MAP-ACTION ::= ACTION

ACTION ::= INSERT | DELETE | SELECT | MOVE | MARK |
           | SHOW | HIDE | PUSHBACK | UNDO | SHIFT | CALL
	   | SET | IF | '(' MACRO-NAME ')'

PREDEFINED-SYMBOL ::=
    '@0' | '@1' | '@2' | '@3' | '@4' |
    '@5' | '@6' | '@7' | '@8' | '@9' |
    '@<' | '@=' | '@>' | '@-' | '@+' | '@[' | '@]'
@endverbatim
@verbatim
MACRO-LIST ::= '(' 'macro' MACRO * ')'

MACRO ::= '(' MACRO-NAME MACRO-ACTION * ')'

MACRO-NAME ::= SYMBOL

MACRO-ACTION ::= ACTION
@endverbatim
@verbatim
MODULE-LIST ::= '(' 'module' MODULE * ')'

MODULE ::= '(' MODULE-NAME FUNCTION * ')'

MODULE-NAME ::= SYMBOL

FUNCTION ::= SYMBOL
@endverbatim

各 @c MODULE は外部モジュール (動的ライブラリ) の名前とそのモジュール
が公開する関数名を宣言する。@c FUNCTION が "init" という名前であれば、
この入力メソッド用の入力コンテクストが生成される際にのみ、デフォルトの
引数 (@c CALL の節参照) とともに呼ばれる。 @c FUNCTION が "fini" とい
う名前を持てば, 入力コンテクストが破壊される際にのみ、デフォルトの引数
とともに呼ばれる。

@verbatim
STATE-LIST ::= '(' 'state' STATE * ')'

STATE ::= '(' STATE-NAME BRANCH * ')'

STATE-NAME ::= SYMBOL

BRANCH ::= '(' MAP-NAME BRANCH-ACTION * ')'
	   | '(' nil BRANCH-ACTION * ')'
	   | '(' t BRANCH-ACTION * ')'
@endverbatim

@c BRANCH の最初の形式では、@c MAP-NAME は @c MAP に現われるものでなく
てはならない。この場合、@c MAP-NAME の @c KEYSEQ の一つに合致するキー
列がタイプされれば、 @c BRANCH-ACTION が実行される。

@c BRANCH の二つ目の形式では、その時点の状態のいずれの @c BRANCH にも
合致しないキー列がタイプされれば、@c BRANCH-ACTIONが実行される。

@c BRANCH の三つ目の形式では、すべてのキーを処理した後でその状態に移動
した場合に @c BRANCH-ACTION が実行される。もし初期状態であれば、入力メ
ソッドの入力コンテクストを生成した直後に @c BRANCH-ACTION を実行する。

@verbatim
BRANCH-ACTION ::= ACTION
@endverbatim

入力メソッドは次の二つのシンボルのリストを持つ。

<ul>
<li> マーカリスト

マーカは preediting テキスト中での文字位置を示すシンボルである。@c
MARK アクションはマーカをある位置に設定する。@c MOVE と @c DELETE アク
ションはマーカの位置を参照する。

<li> 変数リスト

変数は整数の値を持つシンボルである。値は@c SET アクションによって設定
され、@c SET, @c INSERT, @c IF に参照される。すべての変数の初期値は 0 
である。

</ul>

@c PREDEFINED-SYMBOL はマーカとして用いられた場合特別な意味を持つ。

<ul>
<li> @c @@0, @c @@1, @c @@2, @c @@3, @c @@4, @c @@5, @c @@6, @c @@7, @c @@8, @c @@9

それぞれ０番目から９番目の位置

<li> @c @@<, @c @@=, @c @@>

最初の、今の、最後の位置

<li> @c @@-, @c @@+

前の、次の位置

<li> @c @@[, @c @@]

候補リストが変化する際の前と次の位置
</ul>

@c PREDEFINED-SYMBOL は @c SELECT アクション中で候補のインデックスとし
て用いられた際特別な意味を持つ。

<ul>
<li> @c @@<, @c @@=, @c @@>

現在の候補グループ中での最初の、今の、最後の候補

<li> @c @@-

前候補。今の候補が今の候補グループ中での最初のものであれば、前の候補グ
ループの最後の候補。

<li> @c @@+

次候補。今の候補が今の候補グループ中での最後のものであれば、次の候補グ
ループの最初の候補。

<li> @c @@[, @c @@]

それぞれ前と後の候補グループ中で、今の候補と同じ候補インデックスを持つ
もの。
</ul>

各アクションの引数と振舞いは以下の通り。

@verbatim
INSERT ::= '(' 'insert' MTEXT ')'
           | MTEXT
	   | INTEGER
           | '(' 'insert' SYMBOL ')'
           | '(' 'insert' '(' CANDIDATES * ')' ')'
           | '(' CANDIDATES * ')' 

CANDIDATES ::= MTEXT | '(' MTEXT * ')'
@endverbatim

第一、第二の形式は @c MTEXT を現在の位置の前に挿入する。

第三の形式は、文字 @c INTEGER を現在の位置の前に挿入する。

第四の形式は、@c SYMBOL を変数として扱い、その値が正しい文字コードで
あれば現在の位置の前に挿入する。

第五、第六の形式では、@c CANDIDATES は候補グループを表し、@c
CANDIDATES の各要素が候補を表す。つまり@c CANDIDATES が M-text であれ
ば、候補はそのM-text 中の文字であり、@c CANDIDATES が M-text のリスト
であれば、候補はそれらの M-text である。

これらの形式は現在の位置の直前に最初の候補を挿入する。挿入された文字列
には、候補のリストと現在選択されている候補を指す情報が付加されている。

挿入によってマーカの位置は自動的に変更される。

@verbatim
DELETE ::= '(' 'delete' SYMBOL ')'
           | '(' 'delete' INTEGER ')'
@endverbatim

第一の形式は @c SYMBOL をマーカとして、マーカと現在の位置の間の文字を
削除する。

第二の形式は @c INTEGER を文字位置として、その文字位置と現在の位置の間
の文字を削除する。

削除によってマーカの位置は自動的に変更される。

@verbatim
SELECT ::= '(' 'select' PREDEFINED-SYMBOL ')'
           | '(' 'select' INTEGER ')'
@endverbatim

このアクションはまず、現在の位置の直前の文字が、候補リストが付加されて
いる文字列に属すかどうかを調べる。そうであれば、その文字列を引数によっ
て指定された候補に入れ換える。

第一の形式では @c PREDEFINED-SYMBOL を前述の候補インデックスとして扱い、
それによって候補リスト中の新しい候補が指定される。

第二の形式では @c INTEGER は候補インデックスであり、候補リスト中の新し
い候補を指定する。

@verbatim
SHOW ::= '(show)'
@endverbatim

このアクションは、入力メソッドドライバに現在の位置の前にある文字列に付
加されている候補リストを示すように指示する。

@verbatim
HIDE ::= '(hide)'
@endverbatim

このアクションは、入力メソッドドライバに現在示されている候補リストを隠
すように指示する。

@verbatim
MOVE ::= '(' 'move' SYMBOL ')'
         | '(' 'move' INTEGER ')'
@endverbatim

第一の形式は @c SYMBOL をマーカとして、それを新しい現在の位置とする。

第二の形式は @c INTEGER を文字位置として、その位置を新しい現在の位置と
する。

@verbatim
MARK ::= '(' 'mark' SYMBOL ')'
@endverbatim

このアクションは @c SYMBOL をマーカとして、それを現在の位置に設定する。
@c SYMBOL は @c PREDEFINED-SYMBOL であってはならない。


@verbatim
PUSHBACK :: = '(pushback INTEGER)'
@endverbatim

このアクションは最新のキーイベントをイベントキューに戻す。

@verbatim
UNDO :: = '(undo)'
@endverbatim

このアクションは最後のキーイベントを取り消す。

@verbatim
SHIFT :: = '(' 'shift' STATE-NAME ')'
@endverbatim

このアクションは現在の状態を @c STATE-NAME に移動させる。 @c
STATE-NAME は @c STATE-LIST に現われるものでなくてはならない。

@verbatim
CALL ::= '(' 'call' MODULE-NAME FUNCTION ARG * ')'

ARG ::= INTEGER | SYMBOL | MTEXT | PLIST
@endverbatim

このアクションは外部モジュール @c MODULE-NAME の関数 @c FUNCTION を呼
ぶ。@c MODULE-NAME と @c FUNCTION は @c MODULE-LIST に現われるものでな
くてはならない。

関数は (#MPlist *) 型の引数とともに呼ばれる。最初の要素のキーは #Mt で
あり、その値は#MInputContext 型のオブジェクトへのポインタである。第二
の要素のキーは#Msymbol であり、値は現在の状態名である。 @c ARGs は三つ
目以降の要素の値として用いられる。それらの要素のキーは自動的に決定され
る。@c ARG が整数値ならば対応するキーは #Minteger であり、@c ARG がシ
ンボルならば、対応するキーは #Msymbol、などのように。

関数は NULL を返すか、または行うべきアクションのリストを表す (#MPlist
*) 型の値を返さなくてはならない。

@verbatim
SET ::= '(' OPERAND SYMBOL1 [ INTEGER | SYMBOL2 ] ')'

OPERAND ::= 'set' | 'add' | 'sub' | 'mul' | 'div'
@endverbatim

このアクションは @c SYMBOL1 と @c SYMBOL2 を変数として、@c SYMBOL1 の
値を以下のように設定する。

@c OPERAND が 'set' ならば、@c SYMBOL1 の値は @c INTEGER または @c
SYMBOL2 に設定される。

@c OPERAND が 'add' ならば、@c SYMBOL1 の値を @c INTEGER または @c
SYMBOL2 の値だけ増やす。

@c OPERAND が 'sub' ならば、@c SYMBOL1 の値を @c INTEGER または @c
SYMBOL2 の値だけ減らす。

@c OPERAND が 'mul' ならば、@c SYMBOL1 の値に @c INTEGER または @c
SYMBOL2 の値を掛ける。

@c OPERAND が 'div' ならば、@c SYMBOL1 の値を @c INTEGER または @c
SYMBOL2 の値で割る。

@verbatim
IF ::= '(' 'if' CONDITION ACTION-LIST1 ACTION-LIST2 * ')'

CONDITION ::= '(' OPERAND VAL1 VAL2 ')'

ACTION-LIST1 ::= '(' ACTION * ')'

ACTION-LIST2 ::= '(' ACTION * ')'

OPERAND ::= '=' '<' '>'

VAL1 ::= [ INTEGER1 | SYMBOL1 ]

VAL2 ::= [ INTEGER2 | SYMBOL2 ]
@endverbatim

このアクションは、 @c CONDITION が真であれば @c ACTION-LIST1 を実行し、
そうでなければ @c ACTION-LIST2 を (もしあれば) 実行する。

@c SYMBOL1 と @c SYMBOL2 は変数として扱われる。

@ifnot FOR-MAN

@subsection im-seealso SEE ALSO

@ref mim-list "Input Methods provided by the m17n database",
@ref mdbGeneral "mdbGeneral(5)"
*/
/***en

@section mdbIM Input Method

@subsection im-description DESCRIPTION

The m17n library provides a driver for input methods that are
dynamically loadable from the m17n database (see @ref m17nInputMethod
@latexonly (P.\pageref{group__m17nInputMethod}) @endlatexonly).

This section describes the data format that defines those input
methods.

@subsection im-format SYNTAX and SEMANTICS

The following data format defines an input method.  The driver loads
a definition from a file, a stream, etc.  A definitions is converted
into the form of plist in the driver.

@verbatim
INPUT-METHOD ::= TITLE MAP-LIST MACRO-LIST ? MODULE-LIST ? STATE-LIST

TITLE ::= '(' 'title' MTEXT ')'
@endverbatim

@c MTEXT is a text displayed on the screen when this input method is
active.

@verbatim
MAP-LIST ::= '(' 'map' MAP * ')'

MAP ::= '(' MAP-NAME RULE * ')'

MAP-NAME ::= SYMBOL

RULE ::= '(' KEYSEQ MAP-ACTION * ')'

KEYSEQ ::= MTEXT | '(' [ SYMBOL | INTEGER ] * ')'
@endverbatim

@c SYMBOL in the definitions of @c MAP-NAME must not be @c t nor @c
nil.

@c MTEXT in the definition of @c KEYSEQ consists of characters that
can be generated by a keyboard.  Therefore @c MTEXT usually contains
only ASCII characters.  However, if the input method is intended to be
used, for instance, with a West European keyboard, @c MTEXT may
contain Latin-1 characters.

@c SYMBOL in the definition of @c KEYSEQ must be the return value of
the minput_event_to_key () function.

@c INTEGER in the definition of @c KEYSEQ must be a valid character
code.

@verbatim
MAP-ACTION ::= ACTION

ACTION ::= INSERT | DELETE | SELECT | MOVE | MARK |
           | SHOW | HIDE | PUSHBACK | UNDO | SHIFT | CALL
	   | SET | IF | '(' MACRO-NAME ')'

PREDEFINED-SYMBOL ::=
    '@0' | '@1' | '@2' | '@3' | '@4' |
    '@5' | '@6' | '@7' | '@8' | '@9' |
    '@<' | '@=' | '@>' | '@-' | '@+' | '@[' | '@]'
@endverbatim
@verbatim
MACRO-LIST ::= '(' 'macro' MACRO * ')'

MACRO ::= '(' MACRO-NAME MACRO-ACTION * ')'

MACRO-NAME ::= SYMBOL

MACRO-ACTION ::= ACTION
@endverbatim
@verbatim
MODULE-LIST ::= '(' 'module' MODULE * ')'

MODULE ::= '(' MODULE-NAME FUNCTION * ')'

MODULE-NAME ::= SYMBOL

FUNCTION ::= SYMBOL
@endverbatim

Each @c MODULE declares the name of external module (i.e. dynamic
library) and function names exported by the module.  If a @c FUNCTION has
name "init", it is called with only the default arguments (see the
section about @c CALL) when an input context is created for the input
method.  If a @c FUNCTION has name "fini", it is called with only the
default arguments when an input context is destroyed.

@verbatim
STATE-LIST ::= '(' 'state' STATE * ')'

STATE ::= '(' STATE-NAME BRANCH * ')'

STATE-NAME ::= SYMBOL

BRANCH ::= '(' MAP-NAME BRANCH-ACTION * ')'
	   | '(' nil BRANCH-ACTION * ')'
	   | '(' t BRANCH-ACTION * ')'
@endverbatim

In the first form of @c BRANCH, @c MAP-NAME must be an item that appears
in @c MAP.  In this case, if a key sequence matching one of @c
KEYSEQs of @c MAP-NAME is typed, @c BRANCH-ACTIONs are executed.

In the second form of @c BRANCH, @c BRANCH-ACTIONs are executed if a
key sequence that doesn't match any of @c Branch's of the current
state is typed.

In the third form of @c BRANCH, @c BRANCH-ACTIONs are executed if we
shift to the current state after handling all typed keys.  If the
current state is the initial state, @c BRANCH-ACTIONs are executed
just after an input context of the input method is created.

@verbatim
BRANCH-ACTION ::= ACTION
@endverbatim

An input method has the following two lists of symbols.

<ul>
<li> marker list

A marker is a symbol indicating a character position in the preediting
text.  The @c MARK action assigns a position to a marker.  The
position of a marker is referred by the @c MOVE and the @c DELETE actions.

<li> variable list

A variable is a symbol associated with an integer value.  The value of
a variable is set by the @c SET action, and is referred by the @c SET,
the @c INSERT, and the @c IF actions.  All variables are implicitly
initialized to zero.

</ul>

Each @c PREDEFINED-SYMBOL has a special meaning when used as a marker.

<ul>
<li> @c @@0, @c @@1, @c @@2, @c @@3, @c @@4, @c @@5, @c @@6, @c @@7, @c @@8, @c @@9

The 0th, 1st, 2nd, ... 9th position respectively.

<li> @c @@<, @c @@=, @c @@>

The first, the current, and the last position.

<li> @c @@-, @c @@+

The previous and the next position.

<li> @c @@[, @c @@]

The previous and the next position where a candidate list changes.
</ul>

Some of the @c PREDEFINED-SYMBOL has a special meaning when used as a candidate
index in the @c SELECT action.

<ul>

<li> @c @@<, @c @@=, @c @@>

The first, the current, and the last candidate of the current candidate group.

<li> @c @@-

The previous candidate.  If the current candidate is the first one in
the current candidate group, then it means the last candidate in the
previous candidate group.

<li> @c @@+

The next candidate.  If the current candidate is the last one in the
current candidate group, then it means the first candidate in the next
candidate group.

<li> @c @@[, @c @@]

The candidate in the previous and the next candidate group having the same
candidate index as the current one.
</ul>

The arguments and the behavior of each action are listed below.

@verbatim
INSERT ::= '(' 'insert' MTEXT ')'
           | MTEXT
	   | INTEGER
           | '(' 'insert' SYMBOL ')'
           | '(' 'insert' '(' CANDIDATES * ')' ')'
           | '(' CANDIDATES * ')' 

CANDIDATES ::= MTEXT | '(' MTEXT * ')'
@endverbatim

The first and second forms insert @c MTEXT before the current position.

The third form inserts the character @c INTEGER before the current
position.

The fourth form treats @c SYMBOL as a variable, and inserts its value
(if it is a valid character code) before the current position.

In the fifth and sixth forms, each @c CANDIDATES represents a
candidate group, and each element of @c CANDIDATES represents a
candidate, i.e. if @c CANDIDATES is an M-text, the candidates are the
characters in the M-text; if @c CANDIDATES is a list of M-texts, the
candidates are the M-texts in the list.

These forms insert the first candidate before the current position.
The inserted string is associated with the list of candidates and
the information indicating the currently selected candidate.

The marker positions affected by the insertion are automatically relocated.

@verbatim
DELETE ::= '(' 'delete' SYMBOL ')'
           | '(' 'delete' INTEGER ')'
@endverbatim

The first form treats @c SYMBOL as a marker, and deletes characters
between the current position and the marker position.

The second form treats @c INTEGER as a character position, and deletes
characters between the current position and the character position.

The marker positions affected by the deletion are automatically relocated.

@verbatim
SELECT ::= '(' 'select' PREDEFINED-SYMBOL ')'
           | '(' 'select' INTEGER ')'
@endverbatim

This action first checks if the character just before the current position
belongs to a string that is associated with a candidate list.  If it is,
the action replaces that string with a candidate specified by the
argument.

The first form treats @c PREDEFINED-SYMBOL as a candidate index (as
described above) that specifies a new candidate in the candidate list.

The second form treats @c INTEGER as a candidate index that specifies a
new candidate in the candidate list.

@verbatim
SHOW ::= '(show)'
@endverbatim

This actions instructs the input method driver to display a candidate
list associated with the string before the current position.

@verbatim
HIDE ::= '(hide)'
@endverbatim

This action instructs the input method driver to hide the currently
displayed candidate list.

@verbatim
MOVE ::= '(' 'move' SYMBOL ')'
         | '(' 'move' INTEGER ')'
@endverbatim

The first form treats @c SYMBOL as a marker, and makes the marker
position be the new current position.

The second form treats @c INTEGER as a character position, and makes
that position be the new current position.

@verbatim
MARK ::= '(' 'mark' SYMBOL ')'
@endverbatim

This action treats @c SYMBOL as a marker, and sets its position to the
current position.  @c SYMBOL must not be a @c PREDEFINED-SYMBOL.


@verbatim
PUSHBACK :: = '(pushback INTEGER)'
@endverbatim

This action pushes back the latest @c INTEGER number of key events to the event queue.

@verbatim
UNDO :: = '(undo)'
@endverbatim

This action cancels the last key event.

@verbatim
SHIFT :: = '(' 'shift' STATE-NAME ')'
@endverbatim

This action shifts the current state to @c STATE-NAME.  @c
STATE-NAME must appear in @c STATE-LIST.

@verbatim
CALL ::= '(' 'call' MODULE-NAME FUNCTION ARG * ')'

ARG ::= INTEGER | SYMBOL | MTEXT | PLIST
@endverbatim

This action calls the function @c FUNCTION of external module @c
MODULE-NAME.  @c MODULE-NAME and @c FUNCTION must appear in @c
MODULE-LIST.

The function is called with an argument of the type (#MPlist *).  The
key of the first element is #Mt and its value is a pointer to an
object of the type #MInputContext.  The key of the second element is
#Msymbol and its value is the current state name.  @c ARGs are used as
the value of the third and later elements.  Their keys are determined
automatically; if an @c ARG is an integer, the corresponding key is
#Minteger; if an @c ARG is a symbol, the corresponding key is
#Msymbol, etc.

The function must return NULL or a value of the type (#MPlist *) that
represents a list of actions to take.

@verbatim
SET ::= '(' OPERAND SYMBOL1 [ INTEGER | SYMBOL2 ] ')'

OPERAND ::= 'set' | 'add' | 'sub' | 'mul' | 'div'
@endverbatim

This action treats @c SYMBOL1 and @c SYMBOL2 as variables and sets the
value of @c SYMBOL1 as below.

If @c OPERAND is 'set', it sets the value of @c SYMBOL1 to @c INTEGER or the
value of @c SYMBOL2.

If @c OPERAND is 'add', it increments the value of @c SYMBOL1 by @c INTEGER
or the value of @c SYMBOL2.

If @c OPERAND is 'sub', it decrements the value of @c SYMBOL1 by @c INTEGER
or the value of @c SYMBOL2.

If @c OPERAND is 'mul', it multiplies the value of @c SYMBOL1 by @c INTEGER
or the value of @c SYMBOL2.

If @c OPERAND is 'div', it divides the value of @c SYMBOL1 by @c INTEGER or
the value of @c SYMBOL2.

@verbatim
IF ::= '(' CONDITION ACTION-LIST1 ACTION-LIST2 * ')'

CONDITION ::= OPERAND VAL1 VAL2

ACTION-LIST1 ::= '(' ACTION * ')'

ACTION-LIST2 ::= '(' ACTION * ')'

OPERAND ::= '=' '<' '>'

VAL1 ::= [ INTEGER1 | SYMBOL1 ]

VAL2 ::= [ INTEGER2 | SYMBOL2 ]
@endverbatim

This action performs actions in @c ACTION-LIST1 if @c CONDITION is
true, and performs @c ACTION-LIST2 (if any) otherwise.

@c SYMBOL1 and @c SYMBOL2 are treated as variables.

@ifnot FOR-MAN

@subsection im-example1 EXAMPLE 1

This is a very simple example for inputting Latin characters with
diacritical marks (acute and cedilla).  For instance, when you type:
@verbatim
    Comme'die-Franc,ais, chic,,
@endverbatim
you will get this:
@if FOR-HTML
@verbatim
    Comm辿die-Fran巽ais, chic,
@endverbatim
@endif
@if FOR-LATEX
@latexonly
\hskip5mm\texttt{\footnotesize Comm\'{e}die-Fran\c{c}ais, chic,}
@endlatexonly
@endif

The definition of the input method is very simple as below, and it is
quite straight forward to extend it to cover all Latin characters.

@if FOR-HTML
@verbatim
(title "latin-postfix")
(map
 (trans
  ("a'" ?叩) ("e'" ?辿) ("i'" ?鱈) ("o'" ?坦) ("u'" ?炭) ("c," ?巽)
  ("A'" ?) ("E'" ?) ("I'" ?) ("O'" ?) ("U'" ?) ("C," ?)
  ("a''" "a'") ("e''" "e'") ("i''" "i'") ("o''" "o'") ("u''" "u'")
  ("c,," "c,")
  ("A''" "A'") ("E''" "E'") ("I''" "I'") ("O''" "O'") ("U''" "U'")
  ("C,," "C,")))
(state
 (init
  (trans)))
@endverbatim
@endif
@if FOR-LATEX
@latexonly
\texttt{\footnotesize
\hskip2mm(title "latin-postfix")\\
\hskip2mm(map\\
\hskip4mm (trans\\
\hskip6mm  ("a'" ?\'{a}) ("e'" ?\'{e}) ("i'" ?\'{i}) ("o'" ?\'{o})
("u'" ?\'{u}) ("c," ?\c{c})\\
\hskip6mm  ("A'" ?\'{A}) ("E'" ?\'{E}) ("I'" ?\'{I}) ("O'" ?\'{O})
("U'" ?\'{U}) ("C," ?\c{C})\\
\hskip6mm  ("a''" "a'") ("e''" "e'") ("i''" "i'") ("o''" "o'") ("u''" "u'")\\
\hskip6mm  ("c,," "c,")\\
\hskip6mm  ("A''" "A'") ("E''" "E'") ("I''" "I'") ("O''" "O'") ("U''" "U'")\\
\hskip6mm  ("C,," "C,")))\\
\hskip2mm(state\\
\hskip4mm (init\\
\hskip6mm  (trans)))}
@endlatexonly
@endif

@subsection im-example2 EXAMPLE 2

This example is for inputting Unicode characters by typing C-u
(Control-u) followed by four hexadecimal numbers.  For instance, when
you type ("^u" means Control-u):
@verbatim
    ^u2190^u2191^u2192^u2193
@endverbatim
you will get this (Unicode arrow symbols):
@verbatim
    
@endverbatim

The definition utilizes @c SET and @c IF commands as below:
@verbatim
(title "UNICODE")
(map
 (starter
  ((C-U) "U+"))
 (hex
  ("0" ?0) ("1" ?1) ... ("9" ?9) ("a" ?A) ("b" ?B) ... ("f" ?F)))
(state
 (init
  (starter (set code 0) (set count 0) (shift unicode)))
 (unicode
  (hex (set this @-)
       (< this ?A
	  ((sub this 48))
	  ((sub this 55)))
       (mul code 16) (add code this)
       (add count 1)
       (= count 4
	  ((delete @<) (insert code) (shift init))))))
@endverbatim

@subsection im-example3 EXAMPLE 3

This example is for inputting Chinese characters by typing PinYin key
sequence.
@if FOR-HTML
For instance, when you type:
@verbatim
    nihaobei2jing2
@endverbatim
you will get:
@verbatim
    篏絅遵篋
@endverbatim

The definition utilizes @c CANDIDATE and @c SELECT commands as below.
Note that this is just an example, and it ignores such important key
as Backspace.

@verbatim
(title "")

(map
 ;; The initial character of Pinyin.
 (starter
  ("a") ("b") ... ("h") ("j") ... ("t") ("w") ("x") ("y") ("z"))

 ;; Big table of Pinyin vs the corresponding Chinese characters.
 (pinyin
  ...
  ("bei" ("茴紊画茣腆" ...))
  ("hao" ("絅遵垽莟羌" ...))
  ("jing" ("膸鋋膕上茘腴" ...))
  ("ni" ("篏√絢羈ラ炊糸Ξ" ...))
  ...)
 ;; Typing 1, 2, ..., 0 selects the 0th, 1st, ..., 9th candidate.
 (choose
  ("1" (select 0)) ("2" (select 1)) ... ("9" (select 8)) ("0" (select 9))))

(state
 (init
  ;; When an initial character of Pinyin is typed, re-handle it in
  ;; "main" state.  Anything else is just produced as is.
  (starter (show) (pushback 1) (shift main)))

 (main
  ;; When a complete Pinyin sequence is typed, shift to "select" state
  ;; to allow users to select one from the candidates.
  (pinyin (shift select))

  ;; When anything else is typed, produce the current candidate (if
  ;; any), and re-handle the last input in "init" state.
  (nil (hide) (shift init)))

 (select
  ;; When a number is typed, select the corresponding canidate,
  ;; produce it, and shift to "init" state.
  (choose (hide) (shift init))

  ;; When anything else is typed, produce the current candidate,
  ;; and re-handle the last input in "init" state.
  (nil (hide) (shift init))))
@endverbatim

@elseif FOR-LATEX
@latexonly
\begin{center}
\fbox{This example is readable only in the documentation of HTML version.}
\end{center}
@endlatexonly
@endif

@endif

@subsection im-seealso SEE ALSO

@ref mim-list "Input Methods provided by the m17n database",
@ref mdbGeneral "mdbGeneral(5)"
*/
